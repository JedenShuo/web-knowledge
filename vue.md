# 关于 ref 与 reactive

在 Vue3 中，响应式系统使用 Proxy 实现对象的依赖收集和更新。对于基本类型，我们用 ref 来包裹，访问要通过 .value。对于对象或数组，我们用 reactive，它返回对象的代理，可以直接修改属性。

# computed 计算属性

用于依赖响应式数据生成新值，有缓存机制：默认懒计算，依赖不变时直接返回缓存值，和 methods 有区别（methods 每次访问计算，computed 会根据编号缓存）

# watch 侦听器

用于监听响应式数据的变化并执行副作用。
支持异步逻辑、深度监视、立即执行等。
watch(person 侦听对象,
(newVal，oldVal) => {
console.log(newVal)数据变化},
{ deep: true }深度监听但会有性能问题，
{ immediate: true }立即执行一次？)

## watchEffect（新语法糖）

自动收集依赖，无需显式声明。
回调立即执行并在依赖变化时重新运行。
用于自动副作用收集，写法更简洁。

# 父子通信

父组件通过 props 向子组件传递数据。
子组件接收 props，但是只读可考虑使用本地副本或者$emit 修改，接收时用 defineProps 可以声明类型，必填，如果 props 需求过多可考虑 pinia

v-model 本质是 props + emit 的语法糖。但仍是单相数据流

子组件通过 $emit 向父组件发送事件。
父组件在子组件上绑定事件接收数据，可传递字符串，对象，数组。
组合 props + emit：父子通信的标准模式，Vue 官方推荐。

# 跨级通信

Provide/Inject
祖先组件提供数据，子孙组件注入数据，不必一层层传递 props。
适用场景：跨多层组件共享数据（主题、语言、用户信息）。

# 插槽

插槽让父组件能把模板内容传给子组件，分为默认插槽、具名插槽和作用域插槽。
默认插槽用于简单内容分发；具名插槽适合多个插槽位置的组件；作用域插槽允许子组件提供数据给父组件渲染。插槽机制可以解耦组件和内容，增加组件复用性和灵活性。

# 生命周期

Vue 组件生命周期分为创建、挂载、更新、销毁四大阶段，每个阶段都有对应钩子函数，例如 created、mounted、updated 等。

# 响应式原理

Vue 2
核心：Object.defineProperty + getter/setter
缺点：
需要递归遍历对象，深层对象需提前定义好，否则无法监听新增属性。
无法检测数组索引变化和新增属性。
Vue 3
核心：Proxy + Reflect
优点：
不需要递归，性能更好。
可以监听对象属性的新增、删除。
支持深度响应，数组/对象操作都可以被捕获。

# 异步更新机制（更新队列）

Vue 更新 DOM 不是同步的，而是异步批处理。
流程:
响应式数据变化 → watcher 被触发
将更新操作 推入微任务队列（异步队列）
同一事件循环中多次数据变化会被 合并（批处理）
异步更新完成后，DOM 才渲染

# 闭包 (Closure)

## 定义

闭包是指函数与其词法作用域绑定在一起时形成的组合。

## 优点

- 实现数据私有化
- 模拟块级作用域
- 延长变量生命周期

## 缺点

- 可能导致内存泄漏（变量无法被垃圾回收）

## 解决办法

- 手动释放闭包引用
- 使用完及时赋值 `null`

# 作用域（scope）

定义：作用域是变量、函数生效的范围。
种类：
全局作用域：定义在 script 标签或模块最外层。
函数作用域：函数内部声明的变量，只在函数内有效。
块级作用域：let、const 引入，{} 内有效。
优点：避免变量冲突，提升代码可维护性。
坑点：早期 var 没有块级作用域 → 容易污染全局。
对比：
var：函数作用域，变量提升。
let/const：块级作用域，存在“暂时性死区”。
暂时行死区：作用域中声明变量前访问会报错，为了避免变量提升带来的混乱

# 变量提升（hoisting）

定义：JS 在代码执行前，会把变量声明和函数声明提升到作用域顶部。
表现：
var 提升后值是 undefined。
function 声明整体提升，可以在定义前调用。
let/const 提升但处于“暂时性死区”，不可在声明前访问。
优缺点：
优点：方便函数先使用后定义。
缺点：容易引发 bug，比如变量值为 undefined 而不是报错。

# this 指向

定义：this 是运行时绑定的，取决于函数调用方式。
规则：
默认绑定（直接调用） → window 或 undefined（严格模式）。
隐式绑定（对象.方法） → 指向对象。
显式绑定（call、apply、bind）。
new 绑定 → 指向新创建的实例。
箭头函数 → 没有 this，继承外层作用域的 this。
常见陷阱：
对象方法赋值给变量后调用，this 丢失。
回调函数里的 this → 默认指向 window。
箭头函数不能作为构造函数，没有自己的 this 与 prototype

# 原型与原型链

定义：
每个对象都有一个隐藏属性 **proto** 指向它的原型对象。
每个函数都有 prototype 属性，用于构造函数创建的实例共享属性和方法。
原型链：对象查找属性时，如果自身没有，就沿着原型链向上找，直到 Object.prototype 或 null。
优点：减少内存占用（方法共享）。
缺点：调试困难，属性冲突时不容易排查。

## new 操作符做了什么？

创建一个空对象。
链接到构造函数的 prototype。
绑定 this 到这个新对象。
如果构造函数有返回对象，则返回该对象，否则返回新对象。

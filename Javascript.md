# 闭包 (Closure)
定义：闭包是指函数与其词法作用域绑定在一起时形成的组合。
优点：实现数据私有化模拟块级作用域延长变量生命周期
缺点：可能导致内存泄漏（变量无法被垃圾回收）
解决办法:手动释放闭包引用使用完及时赋值 `null`

# 作用域（scope）

定义：作用域是变量、函数生效的范围。
种类：全局作用域：定义在 script 标签或模块最外层。
函数作用域：函数内部声明的变量，只在函数内有效。
块级作用域：let、const 引入，{} 内有效。
优点：避免变量冲突，提升代码可维护性。
坑点：早期 var 没有块级作用域 → 容易污染全局。
对比：var：函数作用域，变量提升。let/const：块级作用域，存在“暂时性死区”。
暂时行死区：作用域中声明变量前访问会报错，为了避免变量提升带来的混乱

# 变量提升（hoisting）

定义：JS 在代码执行前，会把变量声明和函数声明提升到作用域顶部。
表现：var 提升后值是 undefined。
function 声明整体提升，可以在定义前调用。
let/const 提升但处于“暂时性死区”，不可在声明前访问。
优缺点：优点：方便函数先使用后定义。
缺点：容易引发 bug，比如变量值为 undefined 而不是报错。

# this 指向

定义：this 是运行时绑定的，取决于函数调用方式。
规则：
默认绑定（直接调用） → window 或 undefined（严格模式）。
隐式绑定（对象.方法） → 指向对象。
显式绑定（call、apply、bind）。
new 绑定 → 指向新创建的实例。
箭头函数 → 没有 this，继承外层作用域的 this。
常见陷阱：对象方法赋值给变量后调用，this 丢失。
回调函数里的 this → 默认指向 window。
箭头函数不能作为构造函数，没有自己的 this 与 prototype

# 原型与原型链

定义：
每个对象都有一个隐藏属性 **proto** 指向它的原型对象。
每个函数都有 prototype 属性，用于构造函数创建的实例共享属性和方法。
原型链：
对象查找属性时，如果自身没有，就沿着原型链向上找，直到 Object.prototype 或 null。
优点：
减少内存占用（方法共享）。
缺点：
调试困难，属性冲突时不容易排查。

## new 操作符做了什么？

创建一个空对象。
链接到构造函数的 prototype。
绑定 this 到这个新对象。
如果构造函数有返回对象，则返回该对象，否则返回新对象。

# window

全局作用域≈window 对象，但两者本质概念不同
在 Node.js 环境下，没有 window，而是 global。
在 ESM 模块里，还有 globalThis（跨平台统一的全局对象）。

# 基本数据类型与复杂数据类型

string number boolean null undefined symbol bigint

object function array date RegExp 等

为什么基本类型在栈里，引用类型在堆里？
基本类型数据量小，存栈里方便快速访问。
引用类型结构复杂、大小不固定，放堆里灵活。
如何判断数据类型？
typeof → 判断基本类型（除了 null 的坑）。
instanceof → 判断引用类型。
Object.prototype.toString.call() → 最精准。

# ES6?

ES6 是 JavaScript 的一个重大更新，补足了很多 ES5 的不足，提高了语法简洁性、可维护性和开发效率。
块级作用域声明
let 和 const 取代 var，避免变量提升和全局污染。
好处：作用域更清晰，减少 bug。
缺点：需要注意暂时性死区（TDZ）。
模板字符串
代替字符串拼接，支持多行和插值 ${}。
可读性更强，不用再写 + 拼接。
解构赋值
从数组或对象中快速提取值。
好处：代码简洁，常配合函数参数。
缺点：解构对象属性时要确保 key 存在，否则是 undefined。
箭头函数
简化函数表达式，并且不会绑定自己的 this。
好处：回调更简洁，避免 that = this。
缺点：不能作为构造函数，没有 arguments 对象。
默认参数 & 剩余参数 & 展开运算符
默认参数：解决 ES5 x = x || 1 这种写法。
剩余参数 ...args：更直观地处理不定参数。

展开运算符：在数组、对象中非常常用。

对象与数组增强

对象字面量简写：{x, y}。

动态属性名：{ [propName]: value }。

数组方法新增 find、includes，更语义化。

模块化（import/export）

ES6 内置模块系统，替代 ES5 的 IIFE 或 CommonJS。

好处：静态分析更容易，打包优化更好。

缺点：浏览器兼容性需要工具链支持。

类（class）与继承

语法糖封装 prototype，更面向对象。

好处：可读性更强，继承更清晰。

缺点：底层还是基于原型，容易给初学者带来误解。

Promise

解决回调地狱问题，配合 async/await 更直观。

缺点：学习曲线稍高，异常处理要注意 catch。

Symbol 和 Map/Set

Symbol 用于对象唯一键。

Map/Set 提供更合适的数据结构（Map 比对象键更灵活，Set 去重）。

好处：解决 ES5 对象键只能是字符串的问题。

# 回调函数

回调函数就是作为参数传递并在特定时机调用的函数，常见于异步编程，比如定时器、事件、ajax。好处是解耦逻辑、提高复用，但缺点是容易造成“回调地狱”和异常处理困难。后来有了 Promise 和 async/await 来优化回调的写法。常见有定时器，事件监听，数组方法
var 在 for 循环中只有一个作用域，所有迭代共享同一个变量，所以异步回调会输出同一个值。而 let 在 ES6 规范中为每次迭代创建了一个新的作用域，相当于给每次循环“复制”一个新的 i，如果必须使用 var 则可以用立即执行函数

# 宏任务，微任务

JS 里的异步分为宏任务和微任务。常见的宏任务有 setTimeout、setInterval、事件回调，常见的微任务有 Promise.then、MutationObserver、queueMicrotask。执行顺序是：先执行一个宏任务 → 清空所有微任务 → 再执行下一个宏任务。因为微任务优先级更高，所以 Promise 回调往往比 setTimeout 先执行。

# 深拷贝与浅拷贝
浅拷贝：只拷贝第一层属性的值，如果属性是引用类型（对象/数组），只拷贝引用地址。用Object.assign()、展开运算符 ...、Array.slice()
深拷贝：完全复制一个独立的新对象，新旧对象互不影响。JSON.parse(JSON.stringify())简单但是丢失函数，symbol，undefind、structuredClone()现代浏览器原生支持、_.cloneDeep()lodash支持
在大型对象频繁深拷贝时要注意性能，可以结合场景使用浅拷贝 + 局部手动深拷贝优化